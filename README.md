# Шаблоны проектирования

![Диаграмма](https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Uml_classes_ru.svg/300px-Uml_classes_ru.svg.png "Диаграмма")

## Фабричный метод
![Диаграмма](https://upload.wikimedia.org/wikipedia/ru/f/f0/FactoryMethodPattern.png "Диаграмма")

[реализация](https://refactoring.guru/ru/design-patterns/factory-method/java/example)
[реализация из Wikipedia](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))

Factory Method - это паттерн создания объектов, порождающий шаблон (creational pattern). Данный шаблон проектирования предоставляет интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс инстанциировать.

Иными словами, Фабрика делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.

У нас есть класс фабрики в котором присутствует метод возвращающий общий класс продукта.

    public abstract class Creator {
        public abstract Product factoryMethod();
    }

Каждый конкретный класс создатель должен наследовать данный класс и сам решить какой продукт создавать.

    public class ConcreteCreatorA extends Creator {
        @Override
        public Product factoryMethod() {
            return new ConcreteProductA();
        }
    }

## Одиночка

Задача этого шаблона ограничить количество экземпляров некоторого класса в пределах приложения.

![Диаграмма](http://cdn.crunchify.com/wp-content/uploads/2013/02/Singleton-Pattern-Java.png "Диаграмма")

## Абстрактная фабрика

Абстрактная фабрика (англ. Abstract factory) — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.

![Диаграмма](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Abstract_factory_UML.svg/677px-Abstract_factory_UML.svg.png "Диаграмма")

[описание](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0%D1%8F_%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))

У нас есть интерфейс продукта с методами. Есть интерфейс абстрактной фабрики в котором есть методы создания продуктов.

    public interface AbstractFactory {
        Button createButton();
        Checkbox createCheckbox();
    }

Есть классы реализизующие данный интерфейс и все методы и решающие какое именно семество объектов создавать.

    public class MacOSFactory implements AbstractFactory {
        public Button createButton() {
            return new MacOSButton();
        }

        public Checkbox createCheckbox() {
            return new MacOSCheckbox();
        }
    }

### Плюсы

- изолирует конкретные классы;
- упрощает замену семейств продуктов;
- гарантирует сочетаемость продуктов.

### Применение

- Система не должна зависеть от того, как создаются, компонуются и представляются входящие в неё объекты.
- Входящие в семейство взаимосвязанные объекты должны использоваться вместе и вам необходимо обеспечить выполнение этого ограничения.
- Система должна конфигурироваться одним из семейств составляющих её объектов.
- Требуется предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию.

## Строитель (Builder)

Строитель (англ. Builder) — порождающий шаблон проектирования предоставляет способ создания составного объекта.

![Диаграмма](https://refactoring.guru/images/patterns/content/builder/ru-BuilderStructure.png "Диаграмма")

[описание](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%BE%D0%B8%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))

### Цель

Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.

### Плюсы

- позволяет изменять внутреннее представление продукта;
- изолирует код, реализующий конструирование и представление;
- дает более тонкий контроль над процессом конструирования.

### Применение

- алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;
- процесс конструирования должен обеспечивать различные представления конструируемого объекта.

Паттерн Строитель предлагает определить и формализовать все шаги конструирования продукта в общем интерфейсе — Строителе.

Чтобы создать продукт, потребуется поочерёдно вызывать методы класса, реализующего интерфейс Строителя.

В программе может быть несколько видов Строителей, при условии, что все они реализуют общий интерфейс. Они могут по-разному реализовывать шаги строительства (например, делать стены из камня, бронированные двери и прочее). За счёт общего интерфейса, их можно взаимозаменять, чтобы получать продукты с разными свойствами.

Чтобы не загромождать клиентский код вызовами методов Строителя, можно ввести промежуточный класс Директор. В этом случае Директор будет отвечать за порядок вызова шагов, а Строитель — за реализацию этих шагов.

### Шаги реализации

- Убедитесь в том, что у вас есть общие шаги построения продукта, а также вариации шагов, которые приводят к созданию различных представлений продуктов.
- Создайте интерфейс Строителя, с шагами для производства всех возможных представлений продуктов.
- Создайте классы Конкретных строителей для каждого из представлений. Реализуйте их шаги строительства.
- Подумайте о создании класса Директора. Его методы будут создавать различные конфигурации продуктов, вызывая разные шаги одного и того же строителя.
- Клиентский код должен создавать и объекты-Строители и объекты-Директоры. Строители подаются либо в конструктор Директора, либо в его строительный метод.
- Чтобы начать строительство, клиент должен вызывать метод объекта-Директора.
- Результат строительства можно вернуть из Директора, но только если все продукты имеют общий интерфейс. В обратном случае, каждый Строитель должен иметь собственный метод получения результата.

У нас есть интерфейс который должен быть реализован. Данный интерфейс предоставляет методы для построения какого - то объекта и они будут общие для всех наследников.

    public interface Builder {
        void buildSystemBlock(String systemBlock);
        void buildDisplay(String display);
        void buildManipulators(String manipulator);
    }
    
Класс реализующий интерфейс также имеет метод создающий и возвращающий продукт (это могут быть разные методы).
    
    public Computer getComputer() {
            return new Computer(display, systemBlock, manipulator);
        }
        
Для удобства создания мы используем класс Директор в котором реализуем методы и конструируем наш объект.

    public void constructCheapComputer(Builder builder) {
        builder.buildDisplay("Samsung");
        builder.buildSystemBlock("Everest");
        builder.buildManipulators("mouse + keyboard");
    }
    
    
 ## Адаптер (Adapter)

 Адаптер (англ. Adapter) — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.
 
 ![Диаграмма](https://refactoring.guru/images/patterns/content/adapter/ru-AdapterStructure.png "Диаграмма")
 
 [описание](https://ru.wikipedia.org/wiki/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))

Обеспечивает совместную работу классов с несовместимыми интерфейсами.

### Шаги реализации
- Убедитесь, что у вас есть два класса с неудобными интерфейсами:
    - полезный служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой код);
    - один или несколько классов приложения, несовместимых с этим служебным классом из-за неудобного или несовпадающего интерфейса.
- Опишите клиентский интерфейс, через который классы приложения смогли бы использовать сторонний класс.
- Создайте класс адаптера, реализовав этот интерфейс.
- Поместите в адаптер поле-ссылку на объект служебного класса. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.
- Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу стороннему объекту.
- Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять адаптеры в будущем.

### Пример JDK
- InputStreamReader(InputStream is)


## Стратегия (Strategy)

Стратегия (англ. Strategy) — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.

![Диаграмма](https://refactoring.guru/images/patterns/content/strategy/ru-StrategyStructure.png "Диаграмма")
 
[описание](https://ru.wikipedia.org/wiki/%D0%90%D0%B4%D0%B0%D0%BF%D1%82%D0%B5%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))

По типу клиента (или по типу обрабатываемых данных) выбрать подходящий алгоритм, который следует применить. Если используется правило, которое не подвержено изменениям, нет необходимости обращаться к шаблону «стратегия».

Класс, который использует алгоритм (Context), включает абстрактный класс (Strategy), обладающий абстрактным методом, определяющим способ вызова алгоритма. Каждый производный класс реализует один требуемый вариант алгоритма.

Замечание: метод вызова алгоритма не должен быть абстрактным, если требуется реализовать некоторое поведение, принимаемое по умолчанию.

### Шаги реализации
- Определите алгоритм, который подвержен частым изменениям. Также подойдёт алгоритм, имеющий несколько вариаций, которые выбираются во время выполнения программы.
- Создайте интерфейс Стратегии, описывающий этот алгоритм. Он должен быть общим для всех вариантов алгоритма.
- Поместите вариации алгоритма в собственные классы — Конкретные стратегии — которые реализуют этот интерфейс.
- В контексте привязывайтесь к общему интерфейсу алгоритма, а не к конкретным классам реализациям.

У нас есть интерфейс с методом который общий для всех. 

    public interface Strategy {
        int execute(int a, int b);
    }
    
Конкретная стратегия реализует данный метод по своему.

    public class ConcreteStrategyAdd implements Strategy {
        public int execute(int a, int b) {
            return a + b;
        }
    }
    
Также у нас есть класс Context который в setter принимает стратегию и есть метод для выполнения метода стратегии

    public class Context {
        private Strategy strategy;
        public void setStrategy(Strategy strategy) {
            this.strategy = strategy;
        }
        public int strategyExecute(int a, int b){
            return strategy.execute(a, b);
        }
    }
    
## Наблюдатель (Observer)

Наблюдатель (англ. Observer) — поведенческий шаблон проектирования. Также известен как «подчинённые» (Dependents). Создает механизм у класса, который позволяет получать экземпляру объекта этого класса оповещения от других объектов об изменении их состояния, тем самым наблюдая за ними.

![Диаграмма](https://upload.wikimedia.org/wikipedia/commons/8/8a/Observer_UML.png "Диаграмма")

![Диаграмма](https://refactoring.guru/images/patterns/content/observer/ru-ObserverStructure.png "Диаграмма")
 
[описание](https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))

Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.

При реализации шаблона «наблюдатель» обычно используются следующие классы:

- Observable — интерфейс, определяющий методы для добавления, удаления и оповещения наблюдателей;
- Observer — интерфейс, с помощью которого наблюдатель получает оповещение; 
- ConcreteObservable — конкретный класс, который реализует интерфейс Observable;
- ConcreteObserver — конкретный класс, который реализует интерфейс Observer.

### Область применения
Шаблон «наблюдатель» применяется в тех случаях, когда система обладает следующими свойствами:

- существует, как минимум, один объект, рассылающий сообщения;
- имеется не менее одного получателя сообщений, причём их количество и состав могут изменяться во время работы приложения;
- нет надобности очень сильно связывать взаимодействующие объекты, что полезно для повторного использования.
Данный шаблон часто применяют в ситуациях, в которых отправителя сообщений не интересует, что делают получатели с предоставленной им информацией.

### Шаги реализации
- Разбейте вашу функциональность на две части: независимое ядро и опциональные зависимые части.
- Независимое ядро станет Издателем. Зависимые части станут Подписчиками.
- Создайте интерфейс Подписчика. В большинстве случаев, достаточно определить один метод update().
- Создайте интерфейс Издателя и опишите в нём операции управления подпиской. Помните, что издатель должен работать только с общим интерфейсом Подписчиков. Вы можете объявить базовый издатель абстрактным классом. В этом случае, в него можно поместить реализацию подписки по умолчанию.
- Создайте или измените классы Конкретных издателей так, чтобы при каждом изменении состояния, они слали оповещения всем своим подписчикам.
- Реализуйте метод оповещения в Конкретных подписчиках. Издатель может отправлять какие-то данные вместе с оповещением (например, в параметрах). Возможен и другой вариант, когда подписчик, получив оповещение, сам берёт из объекта издателя нужные данные. Но при этом подписчик привяжет себя к конкретному классу издателя.
- Клиент создаёт необходимое количество объектов подписчиков и регистрирует их у издателей.

Observer - наблюдатель

    public interface Observer {
        void update(float temperature, int pressure);
    }
    
Observable - наблюдаемый(за кем наблюдают)

    public interface Observable {
        void registerObserver(Observer o);
        void removeRegister(Observer o);
        void notifyObservers();
    }
    
## Итератор (Iterator)

Iterator — поведенческий шаблон проектирования. Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого из агрегированных объектов.

![Диаграмма](https://refactoring.guru/images/patterns/content/iterator/ru-IteratorStructure.png "Диаграмма")
 
[описание](https://refactoring.guru/ru/design-patterns/iterator)

Даёт возможность последовательно обходить все элементы составного объекта, не раскрывая его внутреннего представления.

## Шаги реализации
- Создайте общий интерфейс Итераторов. Обычно там живут такие операции:  первыйЭлемент, следующийЭлемент, текущийЭлемент, естьЛиЕщеЭлементы.
- Создайте интерфейс Коллекции и опишите в нём метод получитьИтератор, который должен возвращать объект Итератор.
- Создайте классы Конкретных итераторов для тех коллекций, в которых нужно обходить элементы.
- Реализуйте методы получитьИтератор в конкретных классах коллекций. Они должны создавать новый итератор того класса, который способен работать с данным типом коллекции. Коллекция должна передавать собственную ссылку в созданный итератор.
- В клиентском коде и в классах коллекций не должно остаться кода обхода элементов.

Клиент должен будет получать новый итератор из объекта коллекции каждый раз когда ему нужно пройтись по элементам списка.

## Часто используется
- Коллекции

